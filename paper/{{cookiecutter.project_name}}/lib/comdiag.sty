\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{comdiag}

% ---------------------------------------------------------- %
% Package Loading                                            %
% ---------------------------------------------------------- %

\RequirePackage{ifthen}    % Make decisions inside latex

\RequirePackage{tikz}      % Powerful graphics package
  \usetikzlibrary{calc}
  \usetikzlibrary{matrix}
  \usetikzlibrary{arrows}
  \usetikzlibrary{topaths}
  \usetikzlibrary{decorations.markings}


% ---------------------------------------------------------- %
% Dummy Commands                                             %
% ---------------------------------------------------------- %

% These commands are defined elswhere. As I need them here make sure that they are
% defined, even if I don't load the elshewhere afterwards.

\providecommand{\makecommentactive}{}
\providecommand{\makecommentinactive}{}


% ---------------------------------------------------------- %
% Auxiliar Commands                                          %
% ---------------------------------------------------------- %

% Empty Commands
\def\comdiag@emptycmd{}%
\def\comdiag@emptycmdA#1{}%
\def\comdiag@emptycmdB#1#2{}%

% A dummy terminator.
\def\comdiag@terminator{}%

% A mark for missing brackets
\def\comdiag@mark{comdiag@xasdaras345lsdfdfs}

% Let's jump !
\def\comdiag@hop@fi#1\fi{\fi #1}
\def\comdiag@hop@else#1\else#2\fi{\else#2\fi #1}

% Let's eat !
\def\comdiag@eatonespace. {}

% Checks if the argument is blank
\newif\ifcomdiag@blank@cond@%

\def\comdiag@ifblank#1{%
  \ifx \@empty#1\@empty%
    \comdiag@blank@cond@true%
  \else%
    \ifthenelse{\equal{#1}{\space}}{\comdiag@blank@cond@true}{\comdiag@blank@cond@false}
  \fi%
  \ifcomdiag@blank@cond@%
}


% Split First Token and aply an operation
% Usage: \comdiag@splitfirst\operator{expression}
%   \operator must be a command accepting two arguments. The first
%   will be the first token and the second the rest.

\def\comdiag@splitfirst#1#2{%
  \def\comdiag@splitfirst@parser##1##2\comdiag@terminator{%
    #1{##1}{##2}}%
  \comdiag@splitfirst@parser#2\comdiag@terminator%
}


% Splits two operators separed by an operand applies given commands to
% each operand.
% Usage: \comdiag@parseoperands{operand}\operator{expression}
%   \operator must be a command accepting two consecutive arguments.
\def\comdiag@parseoperands#1#2#3{%
  \def\comdiag@parseoperands@parser##1#1##2\comdiag@terminator{#2{##1}{##2}}%
  \comdiag@parseoperands@parser#3\comdiag@terminator%
}


% Splits a sequence separated by a separator and applies given commands
% to element and to each separator.
%
% Usage: \comdiag@parseseq{separator}\operation1\operation2{expression}
%   \operation1 must be a command accepting one argument, and it will
%   be applied to every section.
%
%   \operation2 must accept two arguments and will be applied to every
%   internal delimiter.

\newcounter{comdiag@parseseq@recursion}
\setcounter{comdiag@parseseq@recursion}{0}
\def\comdiag@parseseq#1#2#3#4{%
  \addtocounter{comdiag@parseseq@recursion}{1}
  \def\comdiag@parseseq@parser{%
    \csname comdiag@parseseq@parser\alph{comdiag@parseseq@recursion}%
    \endcsname%
  }%
  \expandafter\expandafter\expandafter\def\comdiag@parseseq@parser##1##2#1##3\comdiag@terminator{%
   \comdiag@ifblank{##1}\else%
     #3{##1}{##2}%
   \fi
    #2{##2}%
    \comdiag@ifblank{##3}\else%
      \comdiag@parseseq@parser{##2}##3\comdiag@terminator%
    \fi%
  }%
  \comdiag@parseseq@parser{}#4\comdiag@terminator%
  \addtocounter{comdiag@parseseq@recursion}{-1}
}


% Catches the first () in the argument and applies \cmd to it.
% Usage: \comdiag@catch@roundpar\cmd{expr}
%    \cmd is where the contents of the ( ... ) are stored.

\def\comdiag@catch@roundpar#1#2{%
  \def\comdiag@catch@roundpar@parser##1(##2)##3\comdiag@terminator{%
    \ifthenelse{\equal{\comdiag@mark}{##2}}{}{%
      #1{##2}%
    }%
  }%
  \comdiag@catch@roundpar@parser#2(\comdiag@mark)\comdiag@terminator%
}

% The same but store in \cmd
\def\comdiag@store@roundpar#1#2{%
  \def\comdiag@store@saver##1{\def#1{##1}}%
  \comdiag@catch@roundpar\comdiag@store@saver{#2}%
}


% Catches the first [] in the argument and applies \cmd to it.
% Usage: \comdiag@catch@squarepar\cmd{expr}
%    \cmd is where the contents of the [ ... ] are stored.

\def\comdiag@catch@squarepar#1#2{%
  \def\comdiag@catch@squarepar@parser##1[##2]##3\comdiag@terminator{%
    \ifthenelse{\equal{\comdiag@mark}{##2}}{}{%
      #1{##2}%
    }%
  }%
  \comdiag@catch@squarepar@parser#2[\comdiag@mark]\comdiag@terminator%
}

% The same but store in \cmd
\def\comdiag@store@squarepar#1#2{%
  \def\comdiag@store@saver##1{\def#1{##1}}%
  \comdiag@catch@squarepar\comdiag@store@saver{#2}%
}



% Catches the first balanced {} in the argument and applies \cmd to it.
% Usage: \comdiag@catch@curlypar\cmd{expr}
%    \cmd is where the contents of the { ... } are stored.

\let\comdiag@catch@bg{

\def\comdiag@catch@curlypar#1#2{%
  \def\comdiag@catch@curlypar@parserB##1##2\comdiag@terminator{%
    \ifthenelse{\equal{\comdiag@mark}{##1}}{}{%
      #1{##1}%
    }%
  }%
  \def\comdiag@catch@curlypar@parser{%
%    (\comdiag@catch@curlypar@next)
    \ifx\comdiag@catch@curlypar@next\comdiag@catch@bg%
      \comdiag@hop@else%
      \comdiag@catch@curlypar@parserB%
    \else%
      \comdiag@hop@fi%
      \comdiag@catch@dofuturelet%
    \fi%
  }%
%
  \def\comdiag@catch@dofutureletB{%
    \if\comdiag@catch@curlypar@next\space%
      \comdiag@hop@else%
      \expandafter\comdiag@catch@dofuturelet\expandafter.\comdiag@eatonespace.%
    \else%
      \comdiag@hop@fi%
      \comdiag@catch@curlypar@parser%
    \fi%
  }%
%
  \def\comdiag@catch@dofuturelet##1{%[##1]
    \futurelet\comdiag@catch@curlypar@next%
    \comdiag@catch@dofutureletB%
  }%
%
  \comdiag@catch@dofuturelet.#2{\comdiag@mark}\comdiag@terminator%
}

% The same but store in \cmd
\def\comdiag@store@curlypar#1#2{%
  \def\comdiag@store@saver##1{\def#1{##1}}%
  \comdiag@catch@curlypar\comdiag@store@saver{#2}%
}


% Catches an optional square bracket at the beginning. Executes
% \cmdopt to it. Then executes \cmdrest with argument the rest if the
% expression.
% Usage: \comdiag@catch@optsquarepar\cmdopt\cmdrest{expr}

\def\comdiag@catch@optsquarepar#1#2#3{%
  \def\comdiag@catch@optsquarepar@parserB[##1]##2\comdiag@terminator{%
    #1{##1}%
    #2{##2}%
  }%
  \def\comdiag@catch@optsquarepar@parser##1\comdiag@terminator{%
    \ifx\comdiag@catch@optsquare@next[%
      \comdiag@catch@optsquarepar@parserB##1\comdiag@terminator%
    \else%
      #2{##1}%
    \fi%
  }%
  \futurelet\comdiag@catch@optsquare@next\comdiag@catch@optsquarepar@parser#3\comdiag@terminator%
}





% ---------------------------------------------------------- %
% Tikz Commutative Diagrams                                  %
% ---------------------------------------------------------- %

% General styles
\tikzset{%
  comdiag style/.style={%
% Sets default styles for comdiag elements. They can be locally
% overriden as opposed to "every bla" styles in tikz.
    matrix style/.style={%
      baseline=(current  bounding  box.center),%
      matrix of math nodes,%
      ampersand replacement=\&,%
      row sep={2.5em,between borders},%
      column sep={2.5em,between borders},%
      text height=1.5ex,%
      text depth=0.25ex%
    },
    morlist style/.style={%
    },
    morchain style/.style={%
      node sep/.code={%
        \comdiag@morchain@setsep{####1}%
      },
      node sep={2.5em,between borders}
    },
    arrows style/.style={%
      every node/.style={%
        execute at begin node=$,%
        execute at end node=$%
      },%
      font=\scriptsize,%
      morphism styles,
      default style/.style={to}%
    },
    objects style/.style={%
      every node/.style={%
        execute at begin node=$,%
        execute at end node=$%
      }%
    },
%   This sets the morphism styles !!
    morphism styles/.style={%
      shift left/.style={transform canvas={%
        shift={($ (\morphismsource)!####1!90:(\morphismtarget) - %
                  (\morphismsource) $)}}},
      shift left/.default={0.4ex},
      shift right/.style={shift left={-####1}},
      shift right/.default={0.4ex},
      arrowtrans/.style={xscale=2.5,yscale=1.1,line width=0.3pt},
      to/.style={%
        domarkings/.style={%
          decoration={markings,%
            mark=at position 1 with {\arrow[arrowtrans]{>}}
        }},
        postaction={domarkings,decorate}
      },
      cof/.style={%
        domarkings/.style={%
          decoration={markings,%
            mark=at position 0 with {\arrow[arrowtrans]{>}},
            mark=at position 1 with {\arrow[arrowtrans]{>}}
        }},
        postaction={domarkings,decorate}
      },
      fib/.style={
        domarkings/.style={%
          decoration={markings,%
            mark=at position -0.3em with {\arrow[arrowtrans]{>}},
            mark=at position 1 with {\arrow[arrowtrans]{>}}
        }},
        postaction={domarkings,decorate}
      },
      into/.style={right hook-,
        domarkings/.style={%
          decoration={markings,%
%            mark=at position 3pt with {\arrowreversed[arrowtrans]{left hook}},
            mark=at position 1 with {\arrow[arrowtrans]{>}}
        }},
        postaction={domarkings,decorate}
      },
      onto/.style={fib},
      maps/.style={
        domarkings/.style={%
          decoration={markings,%
            mark=at position 0 with {\arrow[yscale=0.8]{|}},
            mark=at position 1 with {\arrow[arrowtrans]{>}}
        }},
        postaction={domarkings,decorate}
      },
      rat/.style={dashed,
        domarkings/.style={%
          decoration={markings,%
            mark=at position 1 with {\arrow[arrowtrans]{>}}
        }},
        postaction={domarkings,decorate}
      }
    },
  }%
}

%% Commutative diagram environments

\newcommand{\comdiag@definecmds}{%
  \providecommand{\chain}[1][]{\comdiag@morchain@cmd[##1].}% 
  \providecommand{\mor}[1][]{\comdiag@mor@cmd[##1].}%
  \providecommand{\obj}[1][]{\comdiag@objmatrix[##1]}%
}

\newenvironment{comdiag}[1][]{%
  \begingroup%
  \makecommentinactive%
  \comdiag@definecmds%
  \begin{equation}\begin{aligned}%
  \begin{tikzpicture}[comdiag style,#1]%
}{%
  \end{tikzpicture}%
  \end{aligned}\end{equation}%
  \makecommentactive%
  \endgroup%
  \aftergroup\ignorespaces%
}

\newenvironment{comdiag*}[1][]{%
  \begingroup%
  \makecommentinactive%
  \comdiag@definecmds%
  \begin{equation*}\begin{aligned}%
  \begin{tikzpicture}[comdiag style,#1]%
}{%
  \end{tikzpicture}%
  \end{aligned}\end{equation*}%
  \makecommentactive%
  \endgroup%
  \aftergroup\ignorespaces%
}


% Catches the first arrow label specification block "[..]^[..]{..}
% bla" block it finds in the argument and stores them in several macros.
% Usage: \comdiag@catch@nodeblock{expr}
% The macros used to store the elements are:
% \comdiag@arrowblock@label
% \comdiag@arrowblock@arrowopts
% \comdiag@arrowblock@labelopts
% \comdiag@arrowblock@remaining

\def\comdiag@arrowblock#1{%
  \def\comdiag@arrowblock@parselabel##1{%
    \futurelet\comdiag@arrowblock@next%
    \comdiag@arrowblock@parselabel@parser##1\comdiag@terminator%
  }%
  \def\comdiag@arrowblock@parselabel@parser##1\comdiag@terminator{%
    \ifx\comdiag@arrowblock@next^%
      \comdiag@arrowblock@parselabel@parserA##1\comdiag@terminator%
    \else%
      \ifx\comdiag@arrowblock@next_%
        \comdiag@arrowblock@parselabel@parserB##1\comdiag@terminator%
      \else%
        \def\comdiag@arrowblock@remaining{##1}%
    \fi\fi%
  }%
  \def\comdiag@arrowblock@parselabel@parserA^##1\comdiag@terminator{%
    \def\comdiag@arrowblock@labelopts@pos{auto=left}%
    \def\comdiag@arrowblock@labelopts{auto=left}%
    \comdiag@arrowblock@parselabel@parserC##1\comdiag@terminator%
  }%
  \def\comdiag@arrowblock@parselabel@parserB_##1\comdiag@terminator{%
    \def\comdiag@arrowblock@labelopts@pos{auto=right}%
    \def\comdiag@arrowblock@labelopts{auto=right}%
    \comdiag@arrowblock@parselabel@parserC##1\comdiag@terminator%
  }%
  \def\comdiag@arrowblock@parselabel@parserC##1##2\comdiag@terminator{%
    \def\comdiag@arrowblock@label{##1}%
    \comdiag@catch@optsquarepar\comdiag@arrowblock@storelabelopts%
    \comdiag@arrowblock@storeremaining{##2}%
  }%
  \def\comdiag@arrowblock@storelabelopts##1{%
    \edef\comdiag@arrowblock@labelopts{%
      \comdiag@arrowblock@labelopts@pos,##1}%
  }%
  \def\comdiag@arrowblock@storeremaining##1{%
    \def\comdiag@arrowblock@remaining{##1}%
  }%
  \def\comdiag@arrowblock@storearrowopts##1{%
    \def\comdiag@arrowblock@arrowopts{##1}%
  }%
  \comdiag@catch@optsquarepar\comdiag@arrowblock@storearrowopts%
    \comdiag@arrowblock@parselabel{#1}%
}


% Morchain command
% Produces a row of chained nodes and arrows.
% EXAMPLE:
% \begin{comdiag*}
% \morchain[node sep={3em,between origins}]{A -->[into]^{f}[pos=0.4] B --> C};
% \end{comdiag*}


\def\comdiag@morchain@cmd[#1]#2;{%
  \def\comdiag@morchain@chain{c}%
  \comdiag@store@roundpar\comdiag@morchain@chain{#2}%
  \begin{scope}[morchain style,#1]%
  \comdiag@catch@curlypar\comdiag@morchain@parse@body{#2}%
  \end{scope}%
}

\newcounter{comdiag@morchain@node}%
\def\comdiag@morchain@parse@body#1{%
  \begingroup%
  \begin{scope}[objects style]
  \setcounter{comdiag@morchain@node}{0}%
  \def\comdiag@morchain@prevnode{}
  \comdiag@parseseq{-->}\comdiag@morchain@parse@node%
    \comdiag@emptycmdB{#1-->}%
  \end{scope}
  \begin{scope}[arrows style]
  \setcounter{comdiag@morchain@node}{0}%
  \comdiag@parseseq{-->}\comdiag@emptycmdA%
    \comdiag@morchain@parse@arrow{#1-->}%
  \end{scope}
  \endgroup%
}

\def\comdiag@morchain@parse@node#1{%
  \comdiag@arrowblock{#1}%
  \stepcounter{comdiag@morchain@node}%
  \ifthenelse{\equal{\comdiag@morchain@sepmode}{between origins}}{%
    \ifthenelse{\equal{\comdiag@morchain@prevnode}{}}{%
      \edef\comdiag@morchain@nodeA{0,0}%
    }{%
      \edef\comdiag@morchain@nodeA{\comdiag@morchain@prevnode}%
    }%
    \draw ($(\comdiag@morchain@nodeA)+(\comdiag@morchain@nodesep,0)$) %
    node%
    (\comdiag@morchain@chain-\arabic{comdiag@morchain@node}) %
    {\comdiag@arrowblock@remaining};%
  }{%
    \ifthenelse{\equal{\comdiag@morchain@prevnode}{}}{%
      \edef\comdiag@morchain@nodeA{0,0}%
    }{%
      \edef\comdiag@morchain@nodeA{\comdiag@morchain@prevnode.east}%
    }%
    \draw ($(\comdiag@morchain@nodeA)+(\comdiag@morchain@nodesep,0)$) %
    node[anchor=west]%
    (\comdiag@morchain@chain-\arabic{comdiag@morchain@node}) %
    {\comdiag@arrowblock@remaining};%
  }%
  \edef\comdiag@morchain@prevnode{%
    \comdiag@morchain@chain-\arabic{comdiag@morchain@node}%
  }%
}

\def\comdiag@morchain@parse@arrow#1#2{%
  \def\comdiag@arrowblock@label{}%
  \def\comdiag@arrowblock@arrowopts{}%
  \def\comdiag@arrowblock@labelopts{}%
  \def\comdiag@arrowblock@remaining{}%
  \comdiag@arrowblock{#2}%
%
  \stepcounter{comdiag@morchain@node}%
  \edef\morphismsource{%
    \comdiag@morchain@chain-\arabic{comdiag@morchain@node}%
  }%
  \stepcounter{comdiag@morchain@node}%
  \edef\morphismtarget{%
    \comdiag@morchain@chain-\arabic{comdiag@morchain@node}%
  }%
  \addtocounter{comdiag@morchain@node}{-2}%
%
  \comdiag@ifblank{\comdiag@arrowblock@label}%
    \edef\comdiag@morchain@pathargs{%
      [default style,\comdiag@arrowblock@arrowopts]%
      (\morphismsource) to (\morphismtarget) ;%
    }%
  \else%
    \edef\comdiag@morchain@pathargs{%
      [default style,\comdiag@arrowblock@arrowopts] (\morphismsource) to %
      node [\comdiag@arrowblock@labelopts] %
      {\unexpanded{\comdiag@arrowblock@label}} %
      (\morphismtarget) ;%
    }%
  \fi%
  \expandafter\draw\comdiag@morchain@pathargs%
  \stepcounter{comdiag@morchain@node}%
}

\def\comdiag@morchain@setsep#1{%
  \def\comdiag@morchain@setsep@parser##1,##2,##3\comdiag@terminator{%
    \ifthenelse{\equal{##2}{between origins}}{%
      \def\comdiag@morchain@sepmode{between origins}%
    }{%
      \ifthenelse{\equal{##2}{between borders}}{%
        \def\comdiag@morchain@sepmode{between borders}%
      }{%
        \errmessage{Unknown style "##2"}%
      }%
    }%
    \def\comdiag@morchain@nodesep{##1}%
  }%
  \comdiag@morchain@setsep@parser#1,,\comdiag@terminator%
}


%% Morphism list Command.
%% Produces an set of arrows in a notationally economical way.
%%
%% ToDo: Code needs cleaning and making it more robust.
%%
%% EXAMPLE:
%\begin{comdiag*}
%  \matrix (m){A^{B^C} & B & C\\
%              A & B & C\\};
%
%  \morphisms (m){
%   (1-1) -->^{f} (1-2)-->^{g} (2-2);
%   (2-1) -->     (2-2) -->    (2-3)    [into]^{a}[pos=0.2];
% };
%\end{comdiag*}


\def\comdiag@mor@cmd[#1]#2;{%
  \def\comdiag@mor@matrix{}%
  \comdiag@store@roundpar\comdiag@mor@matrix{#2}%
  \begin{scope}[morlist style,#1]%
  \comdiag@catch@curlypar\comdiag@mor@parse@body{#2}%
  \end{scope}%
}

\def\comdiag@mor@parse@body#1{%
  \begingroup%
  \def\comdiag@mor@firstnode{}%
  \def\comdiag@mor@pathops{}%
  \def\comdiag@mor@secondnode{}%
  \def\comdiag@mor@nodeops{}%
  \def\comdiag@mor@nodelabel{}%
  \def\comdiag@mor@nodekeyword{}%
  \begin{scope}[arrows style]
  \comdiag@parseseq{;}\comdiag@mor@parse@path\comdiag@emptycmdB{#1}%
  \end{scope}
  \endgroup%
}


\def\comdiag@mor@parse@path#1{%
  \def\comdiag@arrowblock@label{}%
  \def\comdiag@arrowblock@arrowopts{}%
  \def\comdiag@arrowblock@labelopts{}%
  \def\comdiag@arrowblock@remaining{}%
  \comdiag@parseseq{-->}\comdiag@mor@parse@tail%
    \comdiag@emptycmdB{#1-->}%
  \comdiag@parseseq{-->}\comdiag@emptycmdA%
    \comdiag@mor@parse@arrow{#1-->}%
}

\def\comdiag@mor@parse@tail#1{%
  \def\comdiag@mor@parse@tail@parser##1(##2) ##3\comdiag@terminator{%
    \comdiag@ifblank{##3}\else%
      \comdiag@arrowblock{##3}%
    \fi%
  }%
  \comdiag@mor@parse@tail@parser#1 \comdiag@terminator%
}%

\def\comdiag@mor@parse@arrow#1#2{%
  \comdiag@store@roundpar\comdiag@mor@firstnode{#1}%
  \comdiag@store@roundpar\comdiag@mor@secondnode{#2}%
  \edef\morphismsource{\comdiag@mor@matrix-\comdiag@mor@firstnode}%
  \edef\morphismtarget{\comdiag@mor@matrix-\comdiag@mor@secondnode}%
  \begingroup%
  \comdiag@arrowblock{#2}%
  \comdiag@ifblank{\comdiag@arrowblock@label}%
    \edef\comdiag@mor@pathargs{%
     [default style,\comdiag@arrowblock@arrowopts] (\morphismsource) to %
     (\morphismtarget) ;%
    }%
  \else%
    \edef\comdiag@mor@pathargs{%
      [default style,\comdiag@arrowblock@arrowopts] (\morphismsource) to %
      node [\comdiag@arrowblock@labelopts] %
      {\unexpanded{\comdiag@arrowblock@label}} %
      (\morphismtarget) ;%
    }%
  \fi%
  \expandafter\draw\comdiag@mor@pathargs%
  \endgroup%
}

%% Object Matrix command
% This is a wraper for the tikz matrix.

\def\comdiag@objmatrix[#1]{%
  \matrix[matrix style,#1]%
}


%% Spectral Sequence Command. Replaces the matrix one.

%% TODO

\tikzstyle{spectral sequence}=[
  every matrix/.style={
    matrix of math nodes,
    nodes in empty cells,
    text height=1.5ex,
    text depth=0.25ex,
    column sep={6ex,between origins},
    row sep={6ex,between origins}
  }
]
